from __future__ import annotations

from collections.abc import Callable
from typing import Protocol, runtime_checkable

from backend.app.contracts.exceptions import AppError


@runtime_checkable
class Result[T, E: Exception](Protocol):
    def is_ok(self) -> bool: ...
    def is_err(self) -> bool: ...
    def map_err[O: Exception](self, err: Callable[[E], O]) -> Result[T, O]: ...
    def map[R](self, f: Callable[[T], R]) -> Result[R, E]: ...
    def map_or[R](self, default: R, f: Callable[[T], R]) -> R: ...
    def and_then[R](self, f: Callable[[T], R | None]) -> Result[R, E]: ...
    def unwrap(self) -> T: ...
    def unwrap_or(self, default: T) -> T: ...
    def unwrap_or_raise(self, err: E) -> T: ...
    def unwrap_or_else(self, f: Callable[[E | None], T]) -> T: ...


type AppResult[T] = Result[T, AppError]
